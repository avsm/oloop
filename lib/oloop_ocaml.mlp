(*							-*-tuareg-*- *)
open Core.Std

(*
 * Reexport some types from the compiler libs to enable sexp on them.
 *)

module Location = struct
    type t =
      Location.t = {
          loc_start: Source_code_position.t;
          loc_end: Source_code_position.t;
          loc_ghost: bool;
        } [@@deriving sexp_of]
  end

module Lexer = struct
  type error =
    Lexer.error =
  | Illegal_character of char
  | Illegal_escape of string
  | Unterminated_comment of Location.t
  | Unterminated_string
#if OCAML_VERSION >= (4, 02, 0)
  | Unterminated_string_in_comment of Location.t * Location.t
#else
  | Unterminated_string_in_comment of Location.t
#endif
  | Keyword_as_label of string
#if OCAML_VERSION < (4, 04, 0)
  | Literal_overflow of string
#else
  | Invalid_literal of string
  | Invalid_directive of string * string option
#endif
  [@@deriving sexp_of]
end

module Syntaxerr = struct
  type error =
    Syntaxerr.error =
  | Unclosed of Location.t * string * Location.t * string
  | Expecting of Location.t * string
#if OCAML_VERSION >= (4, 02, 0)
  | Not_expecting of Location.t * string
#endif
  | Applicative_path of Location.t
  | Variable_in_scope of Location.t * string
  | Other of Location.t
#if OCAML_VERSION >= (4, 02, 0)
  | Ill_formed_ast of Location.t * string
#endif
#if OCAML_VERSION >= (4, 04, 0)
  | Invalid_package_type of Location.t * string
#endif
  [@@deriving sexp_of]
end

module Primitive = struct
#if OCAML_VERSION >= (4, 04, 0)
  type boxed_integer = Primitive.boxed_integer =
    Pnativeint | Pint32 | Pint64
    [@@deriving sexp_of]

  type native_repr = Primitive.native_repr =
    | Same_as_ocaml_repr
    | Unboxed_float
    | Unboxed_integer of boxed_integer
    | Untagged_int
    [@@deriving sexp_of]
#endif

    type description =
      Primitive.description = private
        { prim_name: string;
          prim_arity: int;
          prim_alloc: bool;
          prim_native_name: string;
#if OCAML_VERSION < (4, 04, 0)
          prim_native_float: bool
#else
          prim_native_repr_args: native_repr list;
          prim_native_repr_res: native_repr;
#endif
        } [@@deriving sexp_of]
  end

module Ident = struct
    type t = Ident.t =
               { stamp: int; name: string; mutable flags: int } [@@deriving sexp_of]
end

module Longident = struct
    type t =
      Longident.t =
        Lident of string
      | Ldot of t * string
      | Lapply of t * t
      [@@deriving sexp_of]
  end

module Path = struct
    type t =
      Path.t =
      | Pident of Ident.t
      | Pdot of t * string * int
      | Papply of t * t
      [@@deriving sexp_of]
  end

module Asttypes = struct
    type constant =
      Asttypes.constant =
        Const_int of int
      | Const_char of char
#if OCAML_VERSION >= (4, 02, 0)
      | Const_string of string * string option
#else
      | Const_string of string
#endif
      | Const_float of string
      | Const_int32 of int32
      | Const_int64 of int64
      | Const_nativeint of nativeint
      [@@deriving sexp_of]

    type rec_flag =
      Asttypes.rec_flag =
      | Nonrecursive
      | Recursive
#if OCAML_VERSION < (4, 02, 0)
      | Default
#endif
      [@@deriving sexp_of]

    type direction_flag = Asttypes.direction_flag = Upto | Downto [@@deriving sexp_of]

    type private_flag = Asttypes.private_flag = Private | Public [@@deriving sexp_of]

    type mutable_flag = Asttypes.mutable_flag = Immutable | Mutable [@@deriving sexp_of]

    type virtual_flag = Asttypes.virtual_flag = Virtual | Concrete [@@deriving sexp_of]

    type override_flag = Asttypes.override_flag = Override | Fresh [@@deriving sexp_of]

    type closed_flag = Asttypes.closed_flag = Closed | Open [@@deriving sexp_of]

    type label = string [@@deriving sexp_of]

#if OCAML_VERSION >= (4, 03, 0)
    type arg_label =
      Asttypes.arg_label =
        Nolabel
      | Labelled of string (*  label:T -> ... *)
      | Optional of string (* ?label:T -> ... *)
      [@@deriving sexp_of]
#endif

    type 'a loc = 'a Asttypes.loc = {
          txt : 'a;
          loc : Location.t;
        } [@@deriving sexp_of]

#if OCAML_VERSION >= (4, 02, 0)
    type variance =
      Asttypes.variance =
      | Covariant
      | Contravariant
      | Invariant
      [@@deriving sexp_of]
#endif
  end

module Parsetree = struct
    open Asttypes

#if OCAML_VERSION >= (4, 04, 0)
type constant = Parsetree.constant =
    Pconst_integer of string * char option
  | Pconst_char of char
  | Pconst_string of string * string option
  | Pconst_float of string * char option [@@deriving sexp_of]
#endif

#if OCAML_VERSION >= (4, 02, 0)
    type attribute = string loc * payload
     and extension = string loc * payload
     and attributes = attribute list
     and payload = Parsetree.payload =
       | PStr of structure
#if OCAML_VERSION >= (4, 04, 0)
       | PSig of signature (* : SIG *)
#endif
       | PTyp of core_type
       | PPat of pattern * expression option
     and core_type =
#else
     type core_type =
#endif
       Parsetree.core_type =
         {
           ptyp_desc: core_type_desc;
           ptyp_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           ptyp_attributes: attributes;
#endif
         }
     and core_type_desc =
       Parsetree.core_type_desc =
       | Ptyp_any
       | Ptyp_var of string
#if OCAML_VERSION < (4, 04, 0)
       | Ptyp_arrow of label * core_type * core_type
#else
       | Ptyp_arrow of arg_label * core_type * core_type
#endif
       | Ptyp_tuple of core_type list
       | Ptyp_constr of Longident.t loc * core_type list
#if OCAML_VERSION >= (4, 02, 0)
       | Ptyp_object of (string * attributes * core_type) list * closed_flag
       | Ptyp_class of Longident.t loc * core_type list
#else
       | Ptyp_object of core_field_type list
       | Ptyp_class of Longident.t loc * core_type list * label list
#endif
       | Ptyp_alias of core_type * string
#if OCAML_VERSION >= (4, 02, 0)
       | Ptyp_variant of row_field list * closed_flag * label list option
#else
       | Ptyp_variant of row_field list * bool * label list option
#endif
       | Ptyp_poly of string list * core_type
       | Ptyp_package of package_type
#if OCAML_VERSION >= (4, 02, 0)
       | Ptyp_extension of extension
#endif
     and package_type =
       Longident.t loc * (Longident.t loc * core_type) list
#if OCAML_VERSION < (4, 02, 0)
     and core_field_type =
       Parsetree.core_field_type =
       { pfield_desc: core_field_desc;
         pfield_loc: Location.t }
     and core_field_desc =
       Parsetree.core_field_desc =
       | Pfield of string * core_type
       | Pfield_var
#endif
     and row_field =
       Parsetree.row_field =
#if OCAML_VERSION >= (4, 02, 0)
       | Rtag of label * attributes * bool * core_type list
#else
       | Rtag of label * bool * core_type list
#endif
       | Rinherit of core_type
     and pattern =
       Parsetree.pattern =
         {
           ppat_desc: pattern_desc;
           ppat_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           ppat_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and pattern_desc =
       Parsetree.pattern_desc =
       | Ppat_any
       | Ppat_var of string loc
       | Ppat_alias of pattern * string loc
       | Ppat_constant of constant
#if OCAML_VERSION >= (4, 02, 0)
       | Ppat_interval of constant * constant
#endif
       | Ppat_tuple of pattern list
#if OCAML_VERSION >= (4, 02, 0)
       | Ppat_construct of Longident.t loc * pattern option
#else
       | Ppat_construct of Longident.t loc * pattern option * bool
#endif
       | Ppat_variant of label * pattern option
       | Ppat_record of (Longident.t loc * pattern) list * closed_flag
       | Ppat_array of pattern list
       | Ppat_or of pattern * pattern
       | Ppat_constraint of pattern * core_type
       | Ppat_type of Longident.t loc
       | Ppat_lazy of pattern
       | Ppat_unpack of string loc
#if OCAML_VERSION >= (4, 02, 0)
       | Ppat_exception of pattern
       | Ppat_extension of extension
#endif
#if OCAML_VERSION = (4, 04, 0)
       | Ppat_open of Longident.t loc * pattern
#endif
     (* Value expressions *)
     and expression =
       Parsetree.expression =
         {
           pexp_desc: expression_desc;
           pexp_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pexp_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and expression_desc =
       Parsetree.expression_desc =
       | Pexp_ident of Longident.t loc
       | Pexp_constant of constant
#if OCAML_VERSION >= (4, 02, 0)
       | Pexp_let of rec_flag * value_binding list * expression
       | Pexp_function of case list
#if OCAML_VERSION < (4, 04, 0)
       | Pexp_fun of label * expression option * pattern * expression
#else
       | Pexp_fun of arg_label * expression option * pattern * expression
#endif
#else
       | Pexp_let of rec_flag * (pattern * expression) list * expression
       | Pexp_function of label * expression option * (pattern * expression) list
#endif
#if OCAML_VERSION < (4, 04, 0)
       | Pexp_apply of expression * (label * expression) list
#else
       | Pexp_apply of expression * (arg_label * expression) list
#endif
#if OCAML_VERSION >= (4, 02, 0)
       | Pexp_match of expression * case list
       | Pexp_try of expression * case list
#else
       | Pexp_match of expression * (pattern * expression) list
       | Pexp_try of expression * (pattern * expression) list
#endif
       | Pexp_tuple of expression list
#if OCAML_VERSION >= (4, 02, 0)
       | Pexp_construct of Longident.t loc * expression option
#else
       | Pexp_construct of Longident.t loc * expression option * bool
#endif
       | Pexp_variant of label * expression option
       | Pexp_record of (Longident.t loc * expression) list * expression option
       | Pexp_field of expression * Longident.t loc
       | Pexp_setfield of expression * Longident.t loc * expression
       | Pexp_array of expression list
       | Pexp_ifthenelse of expression * expression * expression option
       | Pexp_sequence of expression * expression
       | Pexp_while of expression * expression
#if OCAML_VERSION >= (4, 02, 0)
       | Pexp_for of
           pattern *  expression * expression * direction_flag * expression
       | Pexp_constraint of expression * core_type
       | Pexp_coerce of expression * core_type option * core_type
#else
       | Pexp_for of
           string loc * expression * expression * direction_flag * expression
       | Pexp_constraint of expression * core_type option * core_type option
       | Pexp_when of expression * expression
#endif
       | Pexp_send of expression * string
       | Pexp_new of Longident.t loc
       | Pexp_setinstvar of string loc * expression
       | Pexp_override of (string loc * expression) list
       | Pexp_letmodule of string loc * module_expr * expression
#if OCAML_VERSION >= (4,04,0)
       | Pexp_letexception of extension_constructor * expression
#endif
       | Pexp_assert of expression
#if OCAML_VERSION < (4, 02, 0)
       | Pexp_assertfalse
#endif
       | Pexp_lazy of expression
       | Pexp_poly of expression * core_type option
       | Pexp_object of class_structure
       | Pexp_newtype of string * expression
       | Pexp_pack of module_expr
       | Pexp_open of override_flag * Longident.t loc * expression
#if OCAML_VERSION >= (4, 02, 0)
       | Pexp_extension of extension
#if OCAML_VERSION >= (4, 04, 0)
       | Pexp_unreachable
#endif
     and case =
       Parsetree.case =
         {
           pc_lhs: pattern;
           pc_guard: expression option;
           pc_rhs: expression;
         }
#endif
     (* Value descriptions *)
     and value_description =
       Parsetree.value_description =
         {
#if OCAML_VERSION >= (4, 02, 0)
           pval_name: string loc;
#endif
           pval_type: core_type;
           pval_prim: string list;
#if OCAML_VERSION >= (4, 02, 0)
           pval_attributes: attributes;
#endif
           pval_loc: Location.t;
         }
     (* Type declarations *)
     and type_declaration =
       Parsetree.type_declaration =
         {
#if OCAML_VERSION >= (4, 02, 0)
           ptype_name: string loc;
           ptype_params: (core_type * variance) list;
#else
           ptype_params: string loc option list;
#endif
           ptype_cstrs: (core_type * core_type * Location.t) list;
           ptype_kind: type_kind;
           ptype_private: private_flag;
           ptype_manifest: core_type option;
#if OCAML_VERSION >= (4, 02, 0)
           ptype_attributes: attributes;
#else
           ptype_variance: (bool * bool) list;
#endif
           ptype_loc: Location.t;
         }
#if OCAML_VERSION >= (4, 02, 0)
     and type_kind =
       Parsetree.type_kind =
       | Ptype_abstract
       | Ptype_variant of constructor_declaration list
       | Ptype_record of label_declaration list
       | Ptype_open
     and label_declaration =
       Parsetree.label_declaration =
         {
           pld_name: string loc;
           pld_mutable: mutable_flag;
           pld_type: core_type;
           pld_loc: Location.t;
           pld_attributes: attributes; (* l [@id1] [@id2] : T *)
         }
     and constructor_declaration =
       Parsetree.constructor_declaration =
         {
           pcd_name: string loc;
#if OCAML_VERSION < (4, 04, 0)
           pcd_args: core_type list;
#else
           pcd_args: constructor_arguments;
#endif
           pcd_res: core_type option;
           pcd_loc: Location.t;
           pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
         }
#if OCAML_VERSION >= (4, 04, 0)
     and constructor_arguments = Parsetree.constructor_arguments =
     | Pcstr_tuple of core_type list
     | Pcstr_record of label_declaration list
#endif
     and type_extension =
       Parsetree.type_extension =
       {
         ptyext_path: Longident.t loc;
         ptyext_params: (core_type * variance) list;
         ptyext_constructors: extension_constructor list;
         ptyext_private: private_flag;
         ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       }
     and extension_constructor =
       Parsetree.extension_constructor =
         {
           pext_name: string loc;
           pext_kind : extension_constructor_kind;
           pext_loc : Location.t;
           pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
         }
     and extension_constructor_kind =
       Parsetree.extension_constructor_kind =
#if OCAML_VERSION < (4, 04, 0)
         Pext_decl of core_type list * core_type option
#else
         Pext_decl of constructor_arguments * core_type option
#endif
       | Pext_rebind of Longident.t loc
#else
     and type_kind =
       Parsetree.type_kind =
         Ptype_abstract
       | Ptype_variant of
           (string loc * core_type list * core_type option * Location.t) list
       | Ptype_record of
           (string loc * mutable_flag * core_type * Location.t) list
     and exception_declaration = core_type list
#endif
     (** {2 Class language} *)
     and class_type =
       Parsetree.class_type =
         {
           pcty_desc: class_type_desc;
           pcty_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pcty_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and class_type_desc =
       Parsetree.class_type_desc =
       | Pcty_constr of Longident.t loc * core_type list
       | Pcty_signature of class_signature
#if OCAML_VERSION >= (4, 02, 0)
#if OCAML_VERSION < (4,04,0)
       | Pcty_arrow of label * core_type * class_type
#else
       | Pcty_arrow of arg_label * core_type * class_type
#endif
       | Pcty_extension of extension
#else
       | Pcty_fun of label * core_type * class_type
#endif
     and class_signature =
       Parsetree.class_signature =
         {
           pcsig_self: core_type;
           pcsig_fields: class_type_field list;
#if OCAML_VERSION < (4, 02, 0)
           pcsig_loc: Location.t;
#endif
         }
     and class_type_field =
       Parsetree.class_type_field =
         {
           pctf_desc: class_type_field_desc;
           pctf_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
#endif
         }
     and class_type_field_desc =
       Parsetree.class_type_field_desc =
#if OCAML_VERSION >= (4, 02, 0)
       | Pctf_inherit of class_type
       | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
       | Pctf_method  of (string * private_flag * virtual_flag * core_type)
       | Pctf_constraint  of (core_type * core_type)
       | Pctf_attribute of attribute
       | Pctf_extension of extension
#else
       | Pctf_inher of class_type
       | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
       | Pctf_virt  of (string * private_flag * core_type)
       | Pctf_meth  of (string * private_flag * core_type)
       | Pctf_cstr  of (core_type * core_type)
#endif
     and 'a class_infos =
       'a Parsetree.class_infos =
         {
           pci_virt: virtual_flag;
#if OCAML_VERSION >= (4, 02, 0)
           pci_params: (core_type * variance) list;
#else
           pci_params: string loc list * Location.t;
#endif
           pci_name: string loc;
           pci_expr: 'a;
#if OCAML_VERSION < (4, 02, 0)
           pci_variance: (bool * bool) list;
#endif
           pci_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
#endif
         }
     and class_description = class_type class_infos
     and class_type_declaration = class_type class_infos
     and class_expr =
       Parsetree.class_expr =
         {
           pcl_desc: class_expr_desc;
           pcl_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pcl_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and class_expr_desc =
       Parsetree.class_expr_desc =
       | Pcl_constr of Longident.t loc * core_type list
       | Pcl_structure of class_structure
#if OCAML_VERSION < (4, 04, 0)
       | Pcl_fun of label * expression option * pattern * class_expr
       | Pcl_apply of class_expr * (label * expression) list
#else
       | Pcl_fun of arg_label * expression option * pattern * class_expr
       | Pcl_apply of class_expr * (arg_label * expression) list
#endif
#if OCAML_VERSION >= (4, 02, 0)
       | Pcl_let of rec_flag * value_binding list * class_expr
#else
       | Pcl_let of rec_flag * (pattern * expression) list * class_expr
#endif
       | Pcl_constraint of class_expr * class_type
#if OCAML_VERSION >= (4, 02, 0)
       | Pcl_extension of extension
#endif
     and class_structure =
       Parsetree.class_structure =
         {
#if OCAML_VERSION >= (4, 02, 0)
           pcstr_self: pattern;
#else
           pcstr_pat: pattern;
#endif
           pcstr_fields: class_field list;
         }
     and class_field =
       Parsetree.class_field =
       {
         pcf_desc: class_field_desc;
         pcf_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
         pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
#endif
       }
#if OCAML_VERSION >= (4, 02, 0)
     and class_field_desc =
       Parsetree.class_field_desc =
       | Pcf_inherit of override_flag * class_expr * string option
       | Pcf_val of (string loc * mutable_flag * class_field_kind)
       | Pcf_method of (string loc * private_flag * class_field_kind)
       | Pcf_constraint of (core_type * core_type)
       | Pcf_initializer of expression
       | Pcf_attribute of attribute
       | Pcf_extension of extension
     and class_field_kind =
       Parsetree.class_field_kind =
       | Cfk_virtual of core_type
       | Cfk_concrete of override_flag * expression
#else
     and class_field_desc =
       Parsetree.class_field_desc =
         Pcf_inher of override_flag * class_expr * string option
       | Pcf_valvirt of (string loc * mutable_flag * core_type)
       | Pcf_val of (string loc * mutable_flag * override_flag * expression)
       | Pcf_virt of (string loc * private_flag * core_type)
       | Pcf_meth of (string loc * private_flag * override_flag * expression)
       | Pcf_constr of (core_type * core_type)
       | Pcf_init of expression
#endif
     and class_declaration = class_expr class_infos
     and module_type =
       Parsetree.module_type =
         {
           pmty_desc: module_type_desc;
           pmty_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pmty_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and module_type_desc =
       Parsetree.module_type_desc =
       | Pmty_ident of Longident.t loc
       | Pmty_signature of signature
#if OCAML_VERSION >= (4, 02, 0)
       | Pmty_functor of string loc * module_type option * module_type
       | Pmty_with of module_type * with_constraint list
#else
       | Pmty_functor of string loc * module_type * module_type
       | Pmty_with of module_type * (Longident.t loc * with_constraint) list
#endif
       | Pmty_typeof of module_expr
#if OCAML_VERSION >= (4, 02, 0)
       | Pmty_extension of extension
       | Pmty_alias of Longident.t loc
#endif
     and signature = signature_item list
     and signature_item =
       Parsetree.signature_item =
         {
           psig_desc: signature_item_desc;
           psig_loc: Location.t;
         }
#if OCAML_VERSION >= (4, 02, 0)
     and signature_item_desc =
       Parsetree.signature_item_desc =
       | Psig_value of value_description
#if OCAML_VERSION < (4, 04, 0)
       | Psig_type of type_declaration list
#else
       | Psig_type of rec_flag * type_declaration list
#endif
       | Psig_typext of type_extension
       | Psig_exception of extension_constructor
       | Psig_module of module_declaration
       | Psig_recmodule of module_declaration list
       | Psig_modtype of module_type_declaration
       | Psig_open of open_description
       | Psig_include of include_description
       | Psig_class of class_description list
       | Psig_class_type of class_type_declaration list
       | Psig_attribute of attribute
       | Psig_extension of extension * attributes
     and module_declaration =
       Parsetree.module_declaration =
         {
           pmd_name: string loc;
           pmd_type: module_type;
           pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
           pmd_loc: Location.t;
         }
     and module_type_declaration =
       Parsetree.module_type_declaration =
         {
           pmtd_name: string loc;
           pmtd_type: module_type option;
           pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
           pmtd_loc: Location.t;
         }
     and open_description =
       Parsetree.open_description =
         {
           popen_lid: Longident.t loc;
           popen_override: override_flag;
           popen_loc: Location.t;
           popen_attributes: attributes;
         }
     and 'a include_infos =
       'a Parsetree.include_infos =
         {
           pincl_mod: 'a;
           pincl_loc: Location.t;
           pincl_attributes: attributes;
         }
     and include_description = module_type include_infos
     and include_declaration = module_expr include_infos
     and with_constraint =
       Parsetree.with_constraint =
       | Pwith_type of Longident.t loc * type_declaration
       | Pwith_module of Longident.t loc * Longident.t loc
       | Pwith_typesubst of type_declaration
       | Pwith_modsubst of string loc * Longident.t loc
#else
     and signature_item_desc =
       Parsetree.signature_item_desc =
         Psig_value of string loc * value_description
       | Psig_type of (string loc * type_declaration) list
       | Psig_exception of string loc * exception_declaration
       | Psig_module of string loc * module_type
       | Psig_recmodule of (string loc * module_type) list
       | Psig_modtype of string loc * modtype_declaration
       | Psig_open of override_flag * Longident.t loc
       | Psig_include of module_type
       | Psig_class of class_description list
       | Psig_class_type of class_type_declaration list
     and modtype_declaration =
       Parsetree.modtype_declaration =
         Pmodtype_abstract
       | Pmodtype_manifest of module_type
     and with_constraint =
       Parsetree.with_constraint =
         Pwith_type of type_declaration
       | Pwith_module of Longident.t loc
       | Pwith_typesubst of type_declaration
       | Pwith_modsubst of Longident.t loc
#endif
     (* Value expressions for the module language *)
     and module_expr =
       Parsetree.module_expr =
         {
           pmod_desc: module_expr_desc;
           pmod_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
           pmod_attributes: attributes; (* ... [@id1] [@id2] *)
#endif
         }
     and module_expr_desc =
       Parsetree.module_expr_desc =
       | Pmod_ident of Longident.t loc
       | Pmod_structure of structure
#if OCAML_VERSION >= (4, 02, 0)
       | Pmod_functor of string loc * module_type option * module_expr
#else
       | Pmod_functor of string loc * module_type * module_expr
#endif
       | Pmod_apply of module_expr * module_expr
       | Pmod_constraint of module_expr * module_type
       | Pmod_unpack of expression
#if OCAML_VERSION >= (4, 02, 0)
       | Pmod_extension of extension
#endif
     and structure = structure_item list
     and structure_item =
       Parsetree.structure_item =
         {
           pstr_desc: structure_item_desc;
           pstr_loc: Location.t;
         }
#if OCAML_VERSION >= (4, 02, 0)
     and structure_item_desc =
       Parsetree.structure_item_desc =
       | Pstr_eval of expression * attributes
       | Pstr_value of rec_flag * value_binding list
       | Pstr_primitive of value_description
#if OCAML_VERSION < (4, 04, 0)
       | Pstr_type of type_declaration list
#else
       | Pstr_type of rec_flag * type_declaration list
#endif
       | Pstr_typext of type_extension
       | Pstr_exception of extension_constructor
       | Pstr_module of module_binding
       | Pstr_recmodule of module_binding list
       | Pstr_modtype of module_type_declaration
       | Pstr_open of open_description
       | Pstr_class of class_declaration list
       | Pstr_class_type of class_type_declaration list
       | Pstr_include of include_declaration
       | Pstr_attribute of attribute
       | Pstr_extension of extension * attributes
     and value_binding =
       Parsetree.value_binding =
         {
           pvb_pat: pattern;
           pvb_expr: expression;
           pvb_attributes: attributes;
           pvb_loc: Location.t;
         }
     and module_binding =
       Parsetree.module_binding =
       {
         pmb_name: string loc;
         pmb_expr: module_expr;
         pmb_attributes: attributes;
         pmb_loc: Location.t;
       }
#else
     and structure_item_desc =
       Parsetree.structure_item_desc =
         Pstr_eval of expression
       | Pstr_value of rec_flag * (pattern * expression) list
       | Pstr_primitive of string loc * value_description
       | Pstr_type of (string loc * type_declaration) list
       | Pstr_exception of string loc * exception_declaration
       | Pstr_exn_rebind of string loc * Longident.t loc
       | Pstr_module of string loc * module_expr
       | Pstr_recmodule of (string loc * module_type * module_expr) list
       | Pstr_modtype of string loc * module_type
       | Pstr_open of override_flag * Longident.t loc
       | Pstr_class of class_declaration list
       | Pstr_class_type of class_type_declaration list
       | Pstr_include of module_expr
#endif
     [@@deriving sexp_of]
  end

module Types = struct
    open Asttypes

    type type_expr =
      Types.type_expr =
      { mutable desc: type_desc;
        mutable level: int;
#if OCAML_VERSION < (4, 04, 0)
        mutable id: int
#else
        id: int
#endif
      }

     and type_desc =
       Types.type_desc =
         Tvar of string option
#if OCAML_VERSION < (4, 04, 0)
       | Tarrow of string * type_expr * type_expr * commutable
#else
       | Tarrow of arg_label * type_expr * type_expr * commutable
#endif
       | Ttuple of type_expr list
       | Tconstr of Path.t * type_expr list * abbrev_memo ref
       | Tobject of type_expr * (Path.t * type_expr list) option ref
       | Tfield of string * field_kind * type_expr * type_expr
       | Tnil
       | Tlink of type_expr
       | Tsubst of type_expr         (* for copying *)
       | Tvariant of row_desc
       | Tunivar of string option
       | Tpoly of type_expr * type_expr list
       | Tpackage of Path.t * Longident.t list * type_expr list

     and row_desc =
       Types.row_desc =
         { row_fields: (string * row_field) list;
           row_more: type_expr;
           row_bound: unit; (* kept for compatibility *)
           row_closed: bool;
           row_fixed: bool;
           row_name: (Path.t * type_expr list) option }

     and row_field =
       Types.row_field =
       | Rpresent of type_expr option
       | Reither of bool * type_expr list * bool * row_field option ref
        (* 1st true denotes a constant constructor *)
        (* 2nd true denotes a tag in a pattern matching, and
           is erased later *)
       | Rabsent

     and abbrev_memo =
       Types.abbrev_memo =
         Mnil
       | Mcons of private_flag * Path.t
                  * type_expr * type_expr * abbrev_memo
       | Mlink of abbrev_memo ref

     and field_kind =
       Types.field_kind =
         Fvar of field_kind option ref
       | Fpresent
       | Fabsent

     and commutable =
       Types.commutable =
         Cok
       | Cunknown
       | Clink of commutable ref
     [@@deriving sexp_of]

    module Meths = struct
        type 'a t = 'a Types.Meths.t

        let sexp_of_t (f: 'a -> Sexp.t) (m: 'a t) =
          let add_sexp k v l = Sexp.List [Sexp.Atom k; f v] :: l in
          Sexp.List(Types.Meths.fold add_sexp m [])

        let t_of_sexp (f: Sexp.t -> 'a) = function
          | Sexp.List l ->
             let add (m: 'a t) = function
               | Sexp.List [Sexp.Atom k; v] -> Types.Meths.add k (f v) m
               | _ -> failwith "Oloop: Types.Meths: incorrect sexp" in
             List.fold l ~init:Types.Meths.empty ~f:add
          | Sexp.Atom _ -> failwith "Oloop: Types.Meths: incorrect sexp"
      end

    module Vars = struct
        type 'a t = 'a Types.Vars.t

        let sexp_of_t (f: 'a -> Sexp.t) (m: 'a t) =
          let add_sexp k v l = Sexp.List [Sexp.Atom k; f v] :: l in
          Sexp.List(Types.Vars.fold add_sexp m [])

        let t_of_sexp (f: Sexp.t -> 'a) = function
          | Sexp.List l ->
             let add (m: 'a t) = function
               | Sexp.List [Sexp.Atom k; v] -> Types.Vars.add k (f v) m
               | _ -> failwith "Oloop: Types.Cars: incorrect sexp" in
             List.fold l ~init:Types.Vars.empty ~f:add
          | Sexp.Atom _ -> failwith "Oloop: Types.Vars: incorrect sexp"
      end

    type value_description =
      Types.value_description =
        { val_type: type_expr;                (* Type of the value *)
          val_kind: value_kind;
          val_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
          val_attributes: Parsetree.attributes;
#endif
        }

     and value_kind =
       Types.value_kind =
       | Val_reg                             (* Regular value *)
       | Val_prim of Primitive.description   (* Primitive *)
       | Val_ivar of mutable_flag * string   (* Instance variable (mutable ?) *)
       | Val_self of (Ident.t * type_expr) Meths.t ref *
                       (Ident.t * mutable_flag * virtual_flag
                        * type_expr) Vars.t ref * string * type_expr
                                             (* Self *)
       | Val_anc of (string * Ident.t) list * string (* Ancestor *)
       | Val_unbound                         (* Unbound variable *)
     [@@deriving sexp_of]

    type label_description =
      Types.label_description =
        { lbl_name: string;
          lbl_res: type_expr;
          lbl_arg: type_expr;
          lbl_mut: mutable_flag;
          lbl_pos: int;
          lbl_all: label_description array;
          lbl_repres: record_representation;
          lbl_private: private_flag;
#if OCAML_VERSION >= (4, 02, 0)
          lbl_loc: Location.t;
          lbl_attributes: Parsetree.attributes;
#endif
        }
     and record_representation =
       Types.record_representation =
         Record_regular
       | Record_float
#if OCAML_VERSION >= (4, 04, 0)
       | Record_unboxed of bool
       | Record_inlined of int
       | Record_extension
#endif
       [@@deriving sexp_of]

    module Variance = struct
        type t = Types.Variance.t

        (* FIXME: Variance.t is abstract and does not offer enough
           functions to deconstruct and reconstruct it.  We use the
           fact that we know its internal representation is an [int]. *)
        let t_of_sexp : Sexplib.Sexp.t -> t = fun sexp ->
          (Obj.magic (int_of_sexp sexp) : t)
        let sexp_of_t : t -> Sexplib.Sexp.t = fun t ->
          sexp_of_int(Obj.magic t)
        ;;
      end

    type type_declaration =
      Types.type_declaration =
      { type_params: type_expr list;
        type_arity: int;
        type_kind: type_kind;
        type_private: private_flag;
        type_manifest: type_expr option;
        type_variance: Variance.t list;
        (* covariant, contravariant, weakly contravariant, injective *)
        type_newtype_level: (int * int) option;
        (* definition level * expansion level *)
        type_loc: Location.t;
#if OCAML_VERSION >= (4, 02, 0)
        type_attributes: Parsetree.attributes;
#endif
#if OCAML_VERSION >= (4, 04, 0)
        type_immediate: bool;
        type_unboxed: unboxed_status;
#endif
      }
#if OCAML_VERSION >= (4, 04, 0)
     and unboxed_status = Types.unboxed_status = private {
       unboxed: bool;
       default: bool;
     }
    and constructor_arguments = Types.constructor_arguments =
      | Cstr_tuple of type_expr list
      | Cstr_record of label_declaration list

#endif
#if OCAML_VERSION >= (4, 02, 0)
      and type_kind =
        Types.type_kind =
          Type_abstract
        | Type_record of label_declaration list  * record_representation
        | Type_variant of constructor_declaration list
        | Type_open
      and label_declaration =
        Types.label_declaration =
        {
          ld_id: Ident.t;
          ld_mutable: mutable_flag;
          ld_type: type_expr;
          ld_loc: Location.t;
          ld_attributes: Parsetree.attributes;
        }
      and constructor_declaration =
        Types.constructor_declaration =
        {
          cd_id: Ident.t;
#if OCAML_VERSION < (4, 04, 0)
          cd_args: type_expr list;
#else
          cd_args: constructor_arguments;
#endif
          cd_res: type_expr option;
          cd_loc: Location.t;
          cd_attributes: Parsetree.attributes;
        }
      and extension_constructor =
        Types.extension_constructor =
          {
            ext_type_path: Path.t;
            ext_type_params: type_expr list;
#if OCAML_VERSION < (4, 04, 0)
            ext_args: type_expr list;
#else
            ext_args: constructor_arguments;
#endif
            ext_ret_type: type_expr option;
            ext_private: private_flag;
            ext_loc: Location.t;
            ext_attributes: Parsetree.attributes;
          }
#else
      and type_kind =
        Types.type_kind =
          Type_abstract
        | Type_record of
            (Ident.t * mutable_flag * type_expr) list * record_representation
        | Type_variant of (Ident.t * type_expr list * type_expr option) list
      and exception_declaration =
        Types.exception_declaration =
        { exn_args: type_expr list;
          exn_loc: Location.t }
#endif
      and type_transparence =
        Types.type_transparence =
          Type_public      (* unrestricted expansion *)
        | Type_new         (* "new" type *)
        | Type_private     (* private type *)
      [@@deriving sexp_of]

    module Concr = struct
        type t = Types.Concr.t

        let sexp_of_t (set: t) =
          Sexp.List(Types.Concr.fold (fun v l -> Sexp.Atom v :: l) set [])

        let t_of_sexp = function
          | Sexp.List l ->
             let add (set: t) = function
               | Sexp.Atom v -> Types.Concr.add v set
               | Sexp.List _ -> failwith "Oloop: Types.Meths: incorrect sexp" in
             List.fold l ~init:Types.Concr.empty ~f:add
          | Sexp.Atom _ -> failwith "Oloop: Types.Concr: incorrect sexp"
      end

    type class_type =
      Types.class_type =
      | Cty_constr of Path.t * type_expr list * class_type
      | Cty_signature of class_signature
#if OCAML_VERSION >= (4, 02, 0)
#if OCAML_VERSION >= (4, 04, 0)
      | Cty_arrow of arg_label * type_expr * class_type
#else
      | Cty_arrow of label * type_expr * class_type
#endif
#else
      | Cty_fun of label * type_expr * class_type
#endif
     and class_signature =
       Types.class_signature = {
#if OCAML_VERSION >= (4, 02, 0)
           csig_self: type_expr;
           csig_vars:
             (Asttypes.mutable_flag * Asttypes.virtual_flag * type_expr) Vars.t;
           csig_concr: Concr.t;
           csig_inher: (Path.t * type_expr list) list
#else
           cty_self: type_expr;
           cty_vars: (mutable_flag * virtual_flag * type_expr) Vars.t;
           cty_concr: Concr.t;
           cty_inher: (Path.t * type_expr list) list
#endif
         } [@@deriving sexp_of]

    type class_declaration =
      Types.class_declaration =
      { cty_params: type_expr list;
        mutable cty_type: class_type;
        cty_path: Path.t;
        cty_new: type_expr option;
        cty_variance: Variance.t list;
#if OCAML_VERSION >= (4, 02, 0)
        cty_loc: Location.t;
        cty_attributes: Parsetree.attributes;
#endif
      } [@@deriving sexp_of]

    type class_type_declaration =
      Types.class_type_declaration =
      { clty_params: type_expr list;
        clty_type: class_type;
        clty_path: Path.t;
        clty_variance: Variance.t list;
#if OCAML_VERSION >= (4, 02, 0)
        clty_loc: Location.t;
        clty_attributes: Parsetree.attributes;
#endif
      } [@@deriving sexp_of]


    type module_type =
      Types.module_type =
      | Mty_ident of Path.t
      | Mty_signature of signature
#if OCAML_VERSION >= (4, 02, 0)
      | Mty_functor of Ident.t * module_type option * module_type
#if OCAML_VERSION < (4, 04, 0)
      | Mty_alias of Path.t
#else
      | Mty_alias of alias_presence * Path.t
#endif
#else
      | Mty_functor of Ident.t * module_type * module_type
#endif
#if OCAML_VERSION >= (4, 04, 0)
    and alias_presence = Types.alias_presence =
    | Mta_present
    | Mta_absent
#endif
     and signature = signature_item list

     and signature_item =
       Types.signature_item =
       | Sig_value of Ident.t * value_description
       | Sig_type of Ident.t * type_declaration * rec_status
#if OCAML_VERSION >= (4, 02, 0)
       | Sig_typext of Ident.t * extension_constructor * ext_status
       | Sig_module of Ident.t * module_declaration * rec_status
#else
       | Sig_exception of Ident.t * exception_declaration
       | Sig_module of Ident.t * module_type * rec_status
#endif
       | Sig_modtype of Ident.t * modtype_declaration
       | Sig_class of Ident.t * class_declaration * rec_status
       | Sig_class_type of Ident.t * class_type_declaration * rec_status

#if OCAML_VERSION >= (4, 02, 0)
     and module_declaration =
       Types.module_declaration =
       {
         md_type: module_type;
         md_attributes: Parsetree.attributes;
         md_loc: Location.t;
       }

     and modtype_declaration =
       Types.modtype_declaration =
       {
         mtd_type: module_type option;  (* None: abstract *)
         mtd_attributes: Parsetree.attributes;
         mtd_loc: Location.t;
       }
#else
     and modtype_declaration =
       Types.modtype_declaration =
       | Modtype_abstract
       | Modtype_manifest of module_type
#endif
     and rec_status =
       Types.rec_status =
       | Trec_not
       | Trec_first
       | Trec_next

#if OCAML_VERSION >= (4, 02, 0)
     and ext_status =
       Types.ext_status =
       | Text_first
       | Text_next
       | Text_exception
#endif
     [@@deriving sexp_of]
  end

module Includecore = struct
    type type_mismatch =
      Includecore.type_mismatch =
        Arity
      | Privacy
      | Kind
      | Constraint
      | Manifest
      | Variance
      | Field_type of Ident.t
      | Field_mutable of Ident.t
      | Field_arity of Ident.t
      | Field_names of int * Ident.t * Ident.t
      | Field_missing of bool * Ident.t
      | Record_representation of bool
#if OCAML_VERSION >= (4, 04, 0)
      | Unboxed_representation of bool
      | Immediate
#endif
      [@@deriving sexp_of]
  end

module Env = struct
    open Types

#if OCAML_VERSION >= (4, 04, 0)
    module PathMap = Env.PathMap
#endif

    type t = Env.t
    (* The compiler type is abstract and may contain closures.  We
       replace environments by empty ones. *)

    type summary =
      Env.summary =
      | Env_empty
      | Env_value of summary * Ident.t * value_description
      | Env_type of summary * Ident.t * type_declaration
#if OCAML_VERSION >= (4, 02, 0)
      | Env_extension of summary * Ident.t * extension_constructor
      | Env_module of summary * Ident.t * module_declaration
#else
      | Env_exception of summary * Ident.t * exception_declaration
      | Env_module of summary * Ident.t * module_type
#endif
      | Env_modtype of summary * Ident.t * modtype_declaration
      | Env_class of summary * Ident.t * class_declaration
      | Env_cltype of summary * Ident.t * class_type_declaration
      | Env_open of summary * Path.t
#if OCAML_VERSION >= (4, 02, 0)
      | Env_functor_arg of summary * Ident.t
#endif
#if OCAML_VERSION >= (4, 04, 0)
      | Env_constraints of summary * type_declaration PathMap.t sexp_opaque
#endif
      [@@deriving sexp_of]

    let initial_environment =
      Compmisc.init_path false; (* false because the toploop is not native *)
      Compmisc.initial_env()

    let of_summary sum =
      try
        (* Do the same as Envaux.env_of_only_summary except that it
           uses [sum] as the summary (one cannot set directly the
           summary of a given environment). *)
        let env_from_summary _sum subst =
          Envaux.env_from_summary sum subst in
        Env.env_of_only_summary env_from_summary initial_environment
      with _ ->
        (* FIXME: do we want to report the error? *)
        Env.empty

    let sexp_of_t t =
      sexp_of_summary(Env.summary t)
  end

module Typedecl = struct
    open Types

    type error =
      Typedecl.error =
      | Repeated_parameter
      | Duplicate_constructor of string
      | Too_many_constructors
      | Duplicate_label of string
      | Recursive_abbrev of string
#if OCAML_VERSION >= (4, 02, 0)
      | Cycle_in_def of string * type_expr
#endif
      | Definition_mismatch of type_expr * Includecore.type_mismatch list
      | Constraint_failed of type_expr * type_expr
      | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
      | Type_clash of Env.t * (type_expr * type_expr) list
      | Parameters_differ of Path.t * type_expr * type_expr
      | Null_arity_external
      | Missing_native_external
      | Unbound_type_var of type_expr * type_declaration
#if OCAML_VERSION >= (4, 02, 0)
      | Not_open_type of Path.t
      | Not_extensible_type of Path.t
      | Extension_mismatch of Path.t * Includecore.type_mismatch list
      | Rebind_wrong_type of Longident.t * Env.t * (type_expr * type_expr) list
      | Rebind_mismatch of Longident.t * Path.t * Path.t
      | Rebind_private of Longident.t
#else
      | Unbound_exception of Longident.t
      | Not_an_exception of Longident.t
#endif
      | Bad_variance of int * (bool*bool*bool) * (bool*bool*bool)
      | Unavailable_type_constructor of Path.t
      | Bad_fixed_type of string
#if OCAML_VERSION >= (4, 02, 0)
      | Unbound_type_var_ext of type_expr * extension_constructor
#else
      | Unbound_type_var_exc of type_expr * type_expr
#endif
      | Varying_anonymous
#if OCAML_VERSION >= (4, 04, 0)
      | Val_in_structure
      | Multiple_native_repr_attributes
      | Cannot_unbox_or_untag_type of native_repr_kind
      | Deep_unbox_or_untag_attribute of native_repr_kind
      | Bad_immediate_attribute
      | Bad_unboxed_attribute of string
      | Wrong_unboxed_type_float
      | Boxed_and_unboxed
#endif
      [@@deriving sexp_of]
#if OCAML_VERSION >= (4, 04, 0)
    and native_repr_kind = Typedecl.native_repr_kind = Unboxed | Untagged [@@deriving sexp_of]
#endif
  end

module Typetexp = struct
    open Types

    type error =
      Typetexp.error =
        Unbound_type_variable of string
      | Unbound_type_constructor of Longident.t
      | Unbound_type_constructor_2 of Path.t
      | Type_arity_mismatch of Longident.t * int * int
      | Bound_type_variable of string
      | Recursive_type
      | Unbound_row_variable of Longident.t
      | Type_mismatch of (type_expr * type_expr) list
      | Alias_type_mismatch of (type_expr * type_expr) list
      | Present_has_conjunction of string
      | Present_has_no_type of string
      | Constructor_mismatch of type_expr * type_expr
      | Not_a_variant of type_expr
      | Variant_tags of string * string
      | Invalid_variable_name of string
      | Cannot_quantify of string * type_expr
      | Multiple_constraints_on_type of Longident.t
      | Repeated_method_label of string
      | Unbound_value of Longident.t
      | Unbound_constructor of Longident.t
      | Unbound_label of Longident.t
      | Unbound_module of Longident.t
      | Unbound_class of Longident.t
      | Unbound_modtype of Longident.t
      | Unbound_cltype of Longident.t
      | Ill_typed_functor_application of Longident.t
      | Illegal_reference_to_recursive_module
#if OCAML_VERSION >= (4, 02, 0)
      | Access_functor_as_structure of Longident.t
#endif
#if OCAML_VERSION >= (4, 02, 0)
      | Apply_structure_as_functor of Longident.t
      | Cannot_scrape_alias of Longident.t * Path.t
#endif
      [@@deriving sexp_of]
  end

module Typecore = struct
    open Asttypes
    open Types

    type error =
      Typecore.error =
        Polymorphic_label of Longident.t
      | Constructor_arity_mismatch of Longident.t * int * int
      | Label_mismatch of Longident.t * (type_expr * type_expr) list
      | Pattern_type_clash of (type_expr * type_expr) list
#if OCAML_VERSION >= (4, 02, 0)
      | Or_pattern_type_clash of Ident.t * (type_expr * type_expr) list
#endif
      | Multiply_bound_variable of string
#if OCAML_VERSION >= (4, 04, 0)
      | Orpat_vars of Ident.t * Ident.t list
#else
      | Orpat_vars of Ident.t
#endif
      | Expr_type_clash of (type_expr * type_expr) list
      | Apply_non_function of type_expr
#if OCAML_VERSION >= (4, 04, 0)
      | Apply_wrong_label of arg_label * type_expr
#else
      | Apply_wrong_label of label * type_expr
#endif
      | Label_multiply_defined of string
      | Label_missing of Ident.t list
      | Label_not_mutable of Longident.t
#if OCAML_VERSION >= (4, 02, 0)
#if OCAML_VERSION >= (4, 04, 0)
      | Wrong_name of string * type_expr * string * Path.t * string * string list
#else
      | Wrong_name of string * type_expr * string * Path.t * Longident.t
#endif
#else
      | Wrong_name of string * Path.t * Longident.t
#endif
      | Name_type_mismatch of
          string * Longident.t * (Path.t * Path.t) * (Path.t * Path.t) list
#if OCAML_VERSION >= (4, 02, 0)
      | Invalid_format of string
#else
      | Incomplete_format of string
      | Bad_conversion of string * int * char
#endif
#if OCAML_VERSION >= (4, 04, 0)
      | Undefined_method of type_expr * string * string list option
      | Undefined_inherited_method of string * string list
#else
      | Undefined_method of type_expr * string
      | Undefined_inherited_method of string
#endif
      | Virtual_class of Longident.t
      | Private_type of type_expr
      | Private_label of Longident.t * type_expr
#if OCAML_VERSION >= (4, 04, 0)
      | Unbound_instance_variable of string * string list
#else
      | Unbound_instance_variable of string
#endif
      | Instance_variable_not_mutable of bool * string
      | Not_subtype of (type_expr * type_expr) list * (type_expr * type_expr) list
      | Outside_class
      | Value_multiply_overridden of string
      | Coercion_failure of
          type_expr * type_expr * (type_expr * type_expr) list * bool
      | Too_many_arguments of bool * type_expr
#if OCAML_VERSION >= (4, 04, 0)
      | Abstract_wrong_label of arg_label * type_expr
#else
      | Abstract_wrong_label of label * type_expr
#endif
      | Scoping_let_module of string * type_expr
      | Masked_instance_variable of Longident.t
      | Not_a_variant_type of Longident.t
      | Incoherent_label_order
      | Less_general of string * (type_expr * type_expr) list
      | Modules_not_allowed
      | Cannot_infer_signature
      | Not_a_packed_module of type_expr
      | Recursive_local_constraint of (type_expr * type_expr) list
      | Unexpected_existential
      | Unqualified_gadt_pattern of Path.t * string
#if OCAML_VERSION >= (4, 02, 0)
      | Invalid_interval
      | Invalid_for_loop_index
      | No_value_clauses
      | Exception_pattern_below_toplevel
#endif
#if OCAML_VERSION >= (4, 04, 0)
      | Inlined_record_escape
      | Inlined_record_expected
      | Unrefuted_pattern of Typedtree.pattern sexp_opaque
      | Invalid_extension_constructor_payload
      | Not_an_extension_constructor
      | Literal_overflow of string
      | Unknown_literal of string * char
#endif
      [@@deriving sexp_of]
  end

module Ctype = struct
    open Types

    type class_match_failure =
      Ctype.class_match_failure =
        CM_Virtual_class
      | CM_Parameter_arity_mismatch of int * int
      | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
      | CM_Class_type_mismatch of Env.t * class_type * class_type
      | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
      | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
      | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
      | CM_Non_mutable_value of string
      | CM_Non_concrete_value of string
      | CM_Missing_value of string
      | CM_Missing_method of string
      | CM_Hide_public of string
      | CM_Hide_virtual of string * string
      | CM_Public_method of string
      | CM_Private_method of string
      | CM_Virtual_method of string
      [@@deriving sexp_of]

    type closed_class_failure =
      Ctype.closed_class_failure =
      | CC_Method of type_expr * bool * string * type_expr
      | CC_Value of type_expr * bool * string * type_expr
      [@@deriving sexp_of]
  end


module Typeclass = struct
    open Asttypes
    open Types

    type error =
      Typeclass.error =
      | Unconsistent_constraint of (type_expr * type_expr) list
      | Field_type_mismatch of string * string * (type_expr * type_expr) list
      | Structure_expected of class_type
      | Cannot_apply of class_type
#if OCAML_VERSION >= (4, 03, 0)
      | Apply_wrong_label of arg_label
#else
      | Apply_wrong_label of label
#endif
      | Pattern_type_clash of type_expr
      | Repeated_parameter
      | Unbound_class_2 of Longident.t
      | Unbound_class_type_2 of Longident.t
      | Abbrev_type_clash of type_expr * type_expr * type_expr
      | Constructor_type_mismatch of string * (type_expr * type_expr) list
#if OCAML_VERSION <= (4, 01, 0)
      | Virtual_class of bool * string list * string list
#else
      | Virtual_class of bool * bool * string list * string list
#endif
      | Parameter_arity_mismatch of Longident.t * int * int
      | Parameter_mismatch of (type_expr * type_expr) list
      | Bad_parameters of Ident.t * type_expr * type_expr
      | Class_match_failure of Ctype.class_match_failure list
      | Unbound_val of string
      | Unbound_type_var of (Format.formatter -> unit)
                            * Ctype.closed_class_failure
      | Make_nongen_seltype of type_expr
      | Non_generalizable_class of Ident.t * Types.class_declaration
      | Cannot_coerce_self of type_expr
      | Non_collapsable_conjunction of
          Ident.t * Types.class_declaration * (type_expr * type_expr) list
      | Final_self_clash of (type_expr * type_expr) list
      | Mutability_mismatch of string * mutable_flag
      | No_overriding of string * string
      | Duplicate of string * string
      [@@deriving sexp_of]

  end

module Symtable = struct
    type error =
      Symtable.error =
        Undefined_global of string
      | Unavailable_primitive of string
      | Wrong_vm of string
      | Uninitialized_global of string
      [@@deriving sexp_of]
  end



(*** Suppress values beginning with _.  Lifted straight from uTop:
 * uTop_main.ml
 * ------------
 * Copyright : (c) 2011, Jeremie Dimino <jeremie@dimino.org>
 * Licence   : BSD3
 **)

let rec map_items (unwrap: 'a -> Outcometree.out_sig_item * 'b)
                  (wrap: Outcometree.out_sig_item -> 'b -> 'a)
                  (items: 'a list) : 'a list =
  match items with
  | [] ->
     []
  | item :: items ->
     let sig_item, _ = unwrap item in
     let name, _rec_status =
       match sig_item with
       | Outcometree.Osig_class (_, name, _, _, rs)
       | Outcometree.Osig_class_type (_, name, _, _, rs)
       | Outcometree.Osig_module (name, _, rs)
#if OCAML_VERSION >= (4, 02, 0)
       | Outcometree.Osig_type ({ Outcometree.otype_name = name; _ }, rs) ->
#else
       | Outcometree.Osig_type ((name, _, _, _, _), rs) ->
#endif
          (name, rs)
#if OCAML_VERSION >= (4, 02, 0)
       | Outcometree.Osig_typext ({ Outcometree.oext_name = name; _ }, _)
#else
       | Outcometree.Osig_exception (name, _)
#endif
       | Outcometree.Osig_modtype (name, _)
#if OCAML_VERSION >= (4, 04, 0)
       | Outcometree.Osig_value {oval_name = name;_} ->
          (name, Outcometree.Orec_not)
#else
       | Outcometree.Osig_value (name, _, _) ->
          (name, Outcometree.Orec_not)
#endif
#if OCAML_VERSION >= (4, 03, 0)
       | Outcometree.Osig_ellipsis -> ("", Outcometree.Orec_not)
#endif
     in
     let keep = name = "" || name.[0] <> '_' in
     if keep then
       item :: map_items unwrap wrap items
     else
       (* Replace the [Orec_next] at the head of items by [Orec_first] *)
       let items =
         match items with
         | [] ->
            []
         | item :: items' ->
            let sig_item, extra = unwrap item in
            match sig_item with
            | Outcometree.Osig_class (a, name, b, c, rs) ->
               if rs = Outcometree.Orec_next then
                 wrap (Outcometree.Osig_class
                         (a, name, b, c, Outcometree.Orec_first)) extra
                 :: items'
               else
                 items
            | Outcometree.Osig_class_type (a, name, b, c, rs) ->
               if rs = Outcometree.Orec_next then
                 wrap (Outcometree.Osig_class_type
                         (a, name, b, c, Outcometree.Orec_first)) extra
                 :: items'
               else
                 items
            | Outcometree.Osig_module (name, a, rs) ->
               if rs = Outcometree.Orec_next then
                 wrap (Outcometree.Osig_module
                         (name, a, Outcometree.Orec_first)) extra :: items'
               else
                 items
            | Outcometree.Osig_type (oty, rs) ->
               if rs = Outcometree.Orec_next then
                 wrap (Outcometree.Osig_type
                         (oty, Outcometree.Orec_first)) extra :: items'
               else
                 items
#if OCAML_VERSION >= (4, 02, 0)
            | Outcometree.Osig_typext _
#else
            | Outcometree.Osig_exception _
#endif
#if OCAML_VERSION >= (4, 03, 0)
            | Outcometree.Osig_ellipsis
#endif
            | Outcometree.Osig_modtype _
            | Outcometree.Osig_value _ ->
               items
       in
       map_items unwrap wrap items


let signatures_remove_underscore_names
      (items : Outcometree.out_sig_item list) =
  map_items (fun x -> (x, ())) (fun x () -> x) items

let phrase_remove_underscore_names (phrase:Outcometree.out_phrase) =
  match phrase with
  | Outcometree.Ophr_eval _
  | Outcometree.Ophr_exception _ -> phrase
  | Outcometree.Ophr_signature items ->
     Outcometree.Ophr_signature (map_items (fun x -> x) (fun x y -> (x, y)) items)

(* End of uTop code *)
